import heapq
from collections import deque

graph = {
'S': [('A', 2), ('B', 1)],
'A': [('B', 5), ('C', 11), ('D', 3)],
'B': [('D', 1), ('E', 15)],
'C': [('D', 2), ('F', 1)],
'D': [('C',2),('E', 4), ('F', 5)],
'E': [('F', 1)],
'F': [],
}

heuristic_values = {
'S': 1,
'A': 3,
'B': 15,
'C': 2,
'D': 1,
'E': float('inf'),
'F': 0
}
def heuristic(node, goal=&#39;F&#39;):
  return heuristic_values.get(node, 0)

def bfs(start, goal):
  visited = set()
  queue = deque([start])
  parent = {start: None}
  nodes_generated = 0
  while queue:
    node = queue.popleft()
    if node == goal:
      return nodes_generated, parent
    if node not in visited:
      visited.add(node)
      nodes_generated += 1
      for neighbor, _ in graph.get(node, []):
        if neighbor not in visited:
          parent[neighbor] = node
          queue.append(neighbor)
  return nodes_generated, parent

def dfs(start, goal):
  visited = set()
  stack = [start]
  parent = {start: None}
  nodes_generated = 0
  while stack:
    node = stack.pop()
    if node == goal:
      return nodes_generated, parent
    if node not in visited:
      visited.add(node)
      nodes_generated += 1
    for neighbor, _ in graph.get(node, []):
    if neighbor not in visited:
      parent[neighbor] = node
      stack.append(neighbor)
  return nodes_generated, parent

def ucs(start, goal):
  visited = set()
  queue = [(0, start)]
  parent = {start: None}
  nodes_generated = 0
  costs = {start: 0}
  while queue:
    cost, node = heapq.heappop(queue)
    if node == goal:
      return nodes_generated, parent
    if node not in visited:
      visited.add(node)
      nodes_generated += 1
    for neighbor, edge_cost in graph.get(node, []):
      new_cost = cost + edge_cost
      if neighbor not in costs or new_cost &lt; costs[neighbor]:
        costs[neighbor] = new_cost
        parent[neighbor] = node
        heapq.heappush(queue, (new_cost, neighbor))
  return nodes_generated, parent

def a_star(start, goal):
  visited = set()
  open_list = [(0 + heuristic(start), 0, start)]
  parent = {start: None}
  nodes_generated = 1
  g_costs = {start: 0}
  while open_list:
    f, g, node = heapq.heappop(open_list)
    if node == goal:
      return nodes_generated, parent
    if node not in visited:
      visited.add(node)
    for neighbor, edge_cost in graph.get(node, []):
      new_g = g + edge_cost
      nodes_generated += 1
      if neighbor not in g_costs or new_g<g_costs[neighbor]:
        g_costs[neighbor] = new_g
        f_cost = new_g + heuristic(neighbor, goal)
        parent[neighbor] = node
        heapq.heappush(open_list, (f_cost, new_g, neighbor))
  return nodes_generated, parent

def reconstruct_path(parent, goal):
  path = []
  current = goal
  while current is not None:
    path.append(current)
    current = parent[current]
  return path[::-1]

start_node = 'S'
end_node = 'F'

bfs_nodes, bfs_parent = bfs(start_node, end_node)
dfs_nodes, dfs_parent = dfs(start_node, end_node)
ucs_nodes, ucs_parent = ucs(start_node, end_node)
a_star_nodes, a_star_parent = a_star(start_node, end_node)

bfs_path = reconstruct_path(bfs_parent, end_node)
dfs_path = reconstruct_path(dfs_parent, end_node)
ucs_path = reconstruct_path(ucs_parent, end_node)
a_star_path = reconstruct_path(a_star_parent, end_node)

print(f"Nodes generated by BFS: {bfs_nodes}")
print(f"Path generated by BFS: {bfs_path}")

print(f"Nodes generated by DFS: {dfs_nodes}")
print(f"Path generated by DFS: {dfs_path}")

print(f"Nodes generated by UCS: {ucs_nodes}")
print(f"Path generated by UCS: {ucs_path}")

print(f"Nodes generated by A* Search: {a_star_nodes}")
print(f"Path generated by A* Search: {a_star_path}")
